/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.28                          *
*        Compiled Jan 30 2015, 16:41:06                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "DIALOG.h"
#include "tslib.h"
#include "lcd-cfg.h"

extern void Touch_SetSampleCallback(void (*pf)(int, int, int));
extern void Touch_CacheTheSample(int id, uint32_t x, uint32_t y, uint32_t z, uint32_t lx, uint32_t ly);
extern bool_t Touch_MakeCalibrationData(void);

static const GUI_POINT tstLogPt[TSC_SAMP_NUM] = {
  { .x =  30, .y =  30 },   /* 左上 */
  { .x = LCD_PANEL_XSIZE - 30, .y =  30 }, /* 右上 */
  { .x = LCD_PANEL_XSIZE - 30, .y = LCD_PANEL_YSIZE - 30 }, /* 右下 */
  { .x =  30, .y = LCD_PANEL_YSIZE - 30 }, /* 左下 */
  { .x = LCD_PANEL_XSIZE / 2, .y = LCD_PANEL_YSIZE / 2 }, /* 中间 */
};

#define TST_SAMPLE_NUM    (32)  /* 必须是2的n次方 */
#define SAMPLE_VALID_NUM  (24)

typedef struct {
  uint16_t x[TST_SAMPLE_NUM];
  uint16_t y[TST_SAMPLE_NUM];
  uint16_t z[TST_SAMPLE_NUM];
  uint16_t count;
  uint8_t  isend;
} TssBufferType;

static TssBufferType* tsc_samples = 0;
static TssBufferType tsc_buffer = {0};
static void TakeTscSampleCallback(int x, int y, int z);
static void _quick_sort(uint16_t data[], int left, int right);
static void _copy_array(uint16_t data[], int count);

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0 (GUI_ID_USER + 0x00)

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, LCD_PANEL_XSIZE, LCD_PANEL_YSIZE, 0, 0x0, 0 },
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

/*********************************************************************
*
*       _cbDialog
*
**********************************************************************
*/
static void _cbDialog(WM_MESSAGE* pMsg)
{
  static int index = 0;
  const GUI_BITMAP* bmp;
  WM_HWIN hItem;
  GUI_RECT r;

  switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hItem = pMsg->hWin;
      WINDOW_SetBkColor(hItem, 0x00000000);
      // USER START (Optionally insert additional code for further widget initialization)
      if (tsc_samples == 0) {
        tsc_samples = &tsc_buffer;
        if (tsc_samples == 0) {
          GUI_EndDialog(hItem, 0);
          return;
        }
      }
      if (WM_CreateTimer(hItem, 88, 50, 0) == 0) {
        GUI_EndDialog(hItem, 0);
        return;
      }
      index = 0;
      tsc_samples->count = 0;
      tsc_samples->isend = 0;
      Touch_SetSampleCallback(TakeTscSampleCallback);
      // USER END
      break;

    // USER START (Optionally insert additional message handling)
    case WM_PAINT:
      bmp = GUI_CursorCrossMI.pBitmap;
      if (bmp) {
        GUI_Clear();
        GUI_DrawBitmap(bmp, tstLogPt[index].x - (bmp->XSize / 2), tstLogPt[index].y - (bmp->YSize / 2));
        WM_GetClientRect(&r);
        GUI_SetColor(GUI_YELLOW);
        GUI_SetTextMode(GUI_TM_TRANS);
        GUI_SetFont(GUI_FONT_13_ASCII);
        GUI_DispStringHCenterAt("cross center", (r.x0 + r.x1) / 2, (r.y0 + r.y1) / 2 + 20);
      }
      break;

    case WM_TIMER:
      if (tsc_samples->isend) {
        if (tsc_samples->count >= TST_SAMPLE_NUM + 20) {
          uint32_t x = 0, y = 0, z = 0;

          _copy_array(tsc_samples->x, tsc_samples->count);
          _quick_sort(tsc_samples->x, 0, SAMPLE_VALID_NUM - 1);

          _copy_array(tsc_samples->y, tsc_samples->count);
          _quick_sort(tsc_samples->y, 0, SAMPLE_VALID_NUM - 1);

          _copy_array(tsc_samples->z, tsc_samples->count);
          _quick_sort(tsc_samples->z, 0, SAMPLE_VALID_NUM - 1);

          tsc_samples->x[0] = tsc_samples->x[SAMPLE_VALID_NUM - 1] = tsc_samples->x[(SAMPLE_VALID_NUM - 1) / 2];
          tsc_samples->y[0] = tsc_samples->y[SAMPLE_VALID_NUM - 1] = tsc_samples->y[(SAMPLE_VALID_NUM - 1) / 2];
          tsc_samples->z[0] = tsc_samples->z[SAMPLE_VALID_NUM - 1] = tsc_samples->z[(SAMPLE_VALID_NUM - 1) / 2];

          // 计算样本平均值，剔除最大值最小值。
          for (int n = 0; n < SAMPLE_VALID_NUM; n++) {
            x += tsc_samples->x[n];
            y += tsc_samples->y[n];
            z += tsc_samples->z[n];
          }
          x /= SAMPLE_VALID_NUM;
          y /= SAMPLE_VALID_NUM;
          z /= SAMPLE_VALID_NUM;
          Touch_CacheTheSample(index, x, y, z, tstLogPt[index].x, tstLogPt[index].y);
          index++;
          if (index >= GUI_COUNTOF(tstLogPt)) {
            if (Touch_MakeCalibrationData()) {
              /* 校准参数计算成功，结束对话框 */
              GUI_EndDialog(pMsg->hWin, 0);
              return;
            }
            index = 0;
          }
          WM_Invalidate(pMsg->hWin);
        }
        tsc_samples->count = 0;
        tsc_samples->isend = 0;
      }
      WM_RestartTimer(pMsg->Data.v, 50);
      break;

    case WM_DELETE:
      Touch_SetSampleCallback(0);
      if (tsc_samples) {
        tsc_samples = 0;
      }
      break;

    // USER END
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
static void TakeTscSampleCallback(int x, int y, int z)
{
  if (tsc_samples && (tsc_samples->isend == 0)) {
    if (z < 0) {
      /* 触摸笔已抬起 */
      tsc_samples->isend = 1;
    } else {
      /* 有效的触摸数据 */
      u32_t i = (tsc_samples->count % TST_SAMPLE_NUM);
      tsc_samples->x[i] = x;
      tsc_samples->y[i] = y;
      tsc_samples->z[i] = z;
      tsc_samples->count++;
    }
  }
}

#define SAMPLE_INVALID_NUM  (TST_SAMPLE_NUM - SAMPLE_VALID_NUM)

static void _copy_array(uint16_t data[], int count)
{
  int index = 0, num = SAMPLE_VALID_NUM;

  count %= TST_SAMPLE_NUM;
  if (count > SAMPLE_INVALID_NUM) {
    index = count - SAMPLE_INVALID_NUM;
    num   = SAMPLE_VALID_NUM - index;
  }
  memcpy(&data[index], &data[count], num * 2);
}

/* 按照数值的升序排列指定数组 */
static void _quick_sort(uint16_t data[], int left, int right)
{
  uint16_t val;
  int i, j;

  for (i = left + 1, ++right; i < right; ++i) {
    val = data[i];
    for (j = i; ((j > left) && (val < data[j - 1])); --j) {
      data[j] = data[j - 1];
    }
    data[j] = val;
  }
}

/*********************************************************************
*
*       CreateWindow
*/

WM_HWIN DLG_CreateTSCali(void)
{
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

/*************************** End of file ****************************/
